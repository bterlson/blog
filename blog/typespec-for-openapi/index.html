<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<title>Write OpenAPI with TypeSpec</title>
		<meta name="description" content="Why TypeSpec is the best way to write OpenAPI">
		<link rel="stylesheet" href="https://unpkg.com/normalize.css">
		<link rel="stylesheet" href="https://unpkg.com/magick.css">
		<link rel="alternate" href="/feed/feed.xml" type="application/atom+xml" title="Brian&#39;s Blog">
		<link rel="alternate" href="/feed/feed.json" type="application/json" title="Brian&#39;s Blog">
		<link rel="stylesheet" href="/bundle/a0YpTR6I8Z.css">
	</head>
	<body>
		<a href="#skip" class="visually-hidden">Skip to main content</a>

		<header>
			<h1><a href="/" class="home-link">Brian&#39;s Blog</a></h1>
			<nav>
				<h2 class="visually-hidden">Top level navigation menu</h2>
				<ul class="nav">
					<li class="nav-item"><a href="/">Home</a></li>
					<li class="nav-item"><a href="/blog/">Archive</a></li>
					<li class="nav-item"><a href="https://twitter.com/bterlson">Twitter</a></li>
				</ul>
			</nav>
		</header>

		<main id="skip">
			
<h1>Write OpenAPI with TypeSpec</h1>

<ul class="post-metadata">
	<li><time datetime="2024-03-25">25 March 2024</time></li>
	<li><a href="/tags/typespec/" class="post-tag">TypeSpec</a>, </li>
	<li><a href="/tags/openapi/" class="post-tag">OpenAPI</a></li>
</ul>

<p>I've spent the last few years at Microsoft working on an API definition language called <a href="https://typespec.io">TypeSpec</a>. It's essentially a super flexible protocol-agnostic DSL for describing API shapes. You can try it in your browser at the <a href="https://typespec.io/playground">TypeSpec playground</a>. Many things about it are exciting, but I want to talk about one thing in particular: why TypeSpec is the best way to write OpenAPI.</p>
<h2 id="openapi-the-good-and-the-not-so-good" tabindex="-1">OpenAPI: the good and the not-so-good <a class="header-anchor" href="#openapi-the-good-and-the-not-so-good">#</a></h2>
<p>OpenAPI is pretty great at describing the low level details of how an HTTP API works. It allows software to understand the shape of an API which in turn enables myriad useful things, like generating clients and documentation, configuring API gateways, or generating test cases. The fact that OpenAPI is the most widely used language to describe HTTP APIs is a testament to these strengths.</p>
<p>However, after working with OpenAPI inside Azure, it is also clear to me that OpenAPI suffers a few critical weaknesses. Humans don't find OpenAPI particularly pleasant to author and review, whether in JSON or YAML. The code generation from OpenAPI is often not stellar despite heroic efforts from many in the community<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>. It also struggles when building APIs at scale where its verbosity and lack of reusable components require significant investment in API reviews and governance process.</p>
<p>I believe API-first development principles<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup> are great in theory, but in practice API-first with OpenAPI faces significant headwinds. Developers are likely to opt for code-first approaches that generate OpenAPI as a build artifact. I believe TypeSpec changes the game. Let's see how!</p>
<h2 id="enter-typespec" tabindex="-1">Enter TypeSpec <a class="header-anchor" href="#enter-typespec">#</a></h2>
<p>TypeSpec is designed to be protocol agonstic, but the team has invested heavily in making great OpenAPI 3.0 emit. You can use TypeSpec to define most OpenAPI documents<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup> by using its <code>http</code> standard library which provides various types and decorators to add http-specific metadata like headers, query strings, or status codes. Writing OpenAPI in TypeSpec has many advantages over using OpenAPI directly. What I'll cover today is that TypeSpecs are smaller, more readable, and can use API components.</p>
<h3 id="terse-and-expressive" tabindex="-1">Terse &amp; expressive <a class="header-anchor" href="#terse-and-expressive">#</a></h3>
<p>TypeSpec's syntax and semantics borrow heavily from TypeScript, which is one of the best languages for describing REST API shapes<sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup>. TypeSpec is able to describe complex model shapes and REST endpoints with substantially less typing than OpenAPI, and the end result is much more readable. I've even heard from folks who successfully use TypeSpec syntax to discuss API shapes with non-technical stakeholders!</p>
<p>Let's look at an example of what I mean. You can view the resulting OpenAPI <a href="https://typespec.io/playground?c=aW1wb3J0ICJAdHlwZXNwZWMvaHR0cCI7DQp1c2luZyBIdHRwOw0KDQovKiogQSBjaGFyYWN0ZXIgaW4gYSBmYW50YXN5IFJQRy1zdHlsZSBnYW1lICovDQptb2RlbCBDyTB7DQogIG5hbWU6IHN0cmluZzvEEWlkOiBzYWZlaW50xRBzdGF0dXM6ICJBbGl2ZSIgfCAiRGVhZOQAkCAgY2xhc3M6IEPEBzsNCn3kAJdlbnVtxhIgeyB3YXJyaW9yOyB3aXphcmQ7IMUjQG1pblZhbHVlKDEpxA5heMYOMjApDQpzY2FsYXLFeMUWIGV4dGVuZHMgdWludDjlAPrmAMpTdGF0c%2BYAxnN0cmVuZ3Ro5ADKxzfmAM1udGVsbGlnZW5j5QDmzBxkxFhyaXR5zhnlAKFvcCBnZXTpASsoQHBhdGjsARspOuoBSTs%3D&amp;e=%40typespec%2Fopenapi3&amp;options=%7B%7D">in the playground</a>.</p>
<figure>
<pre class="shiki rose-pine-dawn" style="background-color:#faf4ed;color:#575279" tabindex="0"><code><span class="line"><span style="color:#286983">import</span><span style="color:#EA9D34"> "@typespec/http"</span><span style="color:#797593">;</span></span>
<span class="line"><span style="color:#286983">using</span><span style="color:#56949F"> Http</span><span style="color:#797593">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#9893A5;font-style:italic">/** A character in a fantasy RPG-style game */</span></span>
<span class="line"><span style="color:#286983">model</span><span style="color:#56949F"> Character</span><span style="color:#797593"> {</span></span>
<span class="line"><span style="color:#D7827E;font-style:italic">  name</span><span style="color:#286983">:</span><span style="color:#56949F"> string</span><span style="color:#797593">;</span></span>
<span class="line"><span style="color:#D7827E;font-style:italic">  id</span><span style="color:#286983">:</span><span style="color:#56949F"> safeint</span><span style="color:#797593">;</span></span>
<span class="line"><span style="color:#D7827E;font-style:italic">  status</span><span style="color:#286983">:</span><span style="color:#EA9D34"> "Alive"</span><span style="color:#575279"> | </span><span style="color:#EA9D34">"Dead"</span><span style="color:#797593">;</span></span>
<span class="line"><span style="color:#D7827E;font-style:italic">  class</span><span style="color:#286983">:</span><span style="color:#56949F"> Class</span><span style="color:#797593">;</span></span>
<span class="line"><span style="color:#797593">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#286983">enum</span><span style="color:#56949F"> Class</span><span style="color:#797593"> {</span><span style="color:#D7827E;font-style:italic"> warrior</span><span style="color:#797593">;</span><span style="color:#D7827E;font-style:italic"> wizard</span><span style="color:#797593">;</span><span style="color:#797593"> }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#56949F">@minValue</span><span style="color:#797593">(</span><span style="color:#D7827E">1</span><span style="color:#797593">)</span></span>
<span class="line"><span style="color:#56949F">@maxValue</span><span style="color:#797593">(</span><span style="color:#D7827E">20</span><span style="color:#797593">)</span></span>
<span class="line"><span style="color:#286983">scalar</span><span style="color:#56949F"> statValue</span><span style="color:#286983"> extends</span><span style="color:#56949F"> uint8</span><span style="color:#797593">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#286983">model</span><span style="color:#56949F"> Stats</span><span style="color:#797593"> {</span></span>
<span class="line"><span style="color:#D7827E;font-style:italic">  strength</span><span style="color:#286983">:</span><span style="color:#56949F"> statValue</span><span style="color:#797593">;</span></span>
<span class="line"><span style="color:#D7827E;font-style:italic">  intelligence</span><span style="color:#286983">:</span><span style="color:#56949F"> statValue</span><span style="color:#797593">;</span></span>
<span class="line"><span style="color:#D7827E;font-style:italic">  dexterity</span><span style="color:#286983">:</span><span style="color:#56949F"> statValue</span><span style="color:#797593">;</span></span>
<span class="line"><span style="color:#797593">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#286983">op</span><span style="color:#D7827E"> getCharacter</span><span style="color:#797593">(</span><span style="color:#56949F">@path</span><span style="color:#D7827E;font-style:italic"> id</span><span style="color:#286983">:</span><span style="color:#56949F"> safeint</span><span style="color:#797593">)</span><span style="color:#286983">:</span><span style="color:#56949F"> Character</span><span style="color:#797593">;</span></span></code></pre>
<figcaption>A partial TypeSpec API definition for a fantasy RPG</figcaption></figure>
<p>This TypeSpec ultimately compiles to OpenAPI that is almost 3x the number of lines, and 3.5x as many bytes. The TypeSpec code is fairly easy to read and followâ€”certainly familiar to TypeScript developers, but also obvious enough that anyone can get the gist.</p>
<p>TypeSpec unions in particular demonstrate how TypeSpec's syntax significantly improves readability. Unions provide a single terse syntax that compile to OpenAPI's <code>oneOf</code>, <code>anyOf</code>, and <code>enum</code> constructs. Consider the following TypeSpec and OpenAPI:</p>
<figure>
<pre class="shiki rose-pine-dawn" style="background-color:#faf4ed;color:#575279" tabindex="0"><code><span class="line"><span style="color:#286983">model</span><span style="color:#56949F"> Character</span><span style="color:#797593"> {</span></span>
<span class="line"><span style="color:#9893A5;font-style:italic">  // ... snip other fields ...</span></span>
<span class="line"><span style="color:#D7827E;font-style:italic">  status</span><span style="color:#286983">:</span><span style="color:#EA9D34"> "Alive"</span><span style="color:#575279"> | </span><span style="color:#EA9D34">"Dead"</span><span style="color:#797593">;</span></span>
<span class="line"><span style="color:#797593">}</span></span></code></pre>
<figcaption>A TypeSpec union of literal types</figcaption></figure>
<figure>
<pre class="shiki rose-pine-dawn" style="background-color:#faf4ed;color:#575279" tabindex="0"><code><span class="line"><span style="color:#56949F">status</span><span style="color:#797593">:</span></span>
<span class="line"><span style="color:#56949F">  type</span><span style="color:#797593">:</span><span style="color:#EA9D34"> string</span></span>
<span class="line"><span style="color:#56949F">  enum</span><span style="color:#797593">:</span></span>
<span class="line"><span style="color:#797593">    -</span><span style="color:#EA9D34"> Alive</span></span>
<span class="line"><span style="color:#797593">    -</span><span style="color:#EA9D34"> Dead</span></span></code></pre>
<figcaption>OpenAPI output for a union of literal types</figcaption></figure>
<p>The compiler determined that this was a union of literal types and so the right choice was to emit it as an enum. But if we have a union of object types, it compiles into an anyOf<sup class="footnote-ref"><a href="#fn5" id="fnref5">[5]</a></sup>.</p>
<figure>
<pre class="shiki rose-pine-dawn" style="background-color:#faf4ed;color:#575279" tabindex="0"><code><span class="line"><span style="color:#286983">model</span><span style="color:#56949F"> Character</span><span style="color:#797593"> {</span></span>
<span class="line"><span style="color:#9893A5;font-style:italic">  // ... snip other fields ...</span></span>
<span class="line"><span style="color:#D7827E;font-style:italic">  items</span><span style="color:#286983">:</span><span style="color:#797593"> (</span><span style="color:#56949F">Weapon</span><span style="color:#575279"> | </span><span style="color:#56949F">Armor</span><span style="color:#575279"> | </span><span style="color:#56949F">GenericItem</span><span style="color:#797593">)[]</span></span>
<span class="line"><span style="color:#797593">}</span></span></code></pre>
<figcaption>A TypeSpec union of objects</figcaption>
</figure>
<figure>
<pre class="shiki rose-pine-dawn" style="background-color:#faf4ed;color:#575279" tabindex="0"><code><span class="line"><span style="color:#56949F">items</span><span style="color:#797593">:</span></span>
<span class="line"><span style="color:#56949F">  type</span><span style="color:#797593">:</span><span style="color:#EA9D34"> array</span></span>
<span class="line"><span style="color:#56949F">  items</span><span style="color:#797593">:</span></span>
<span class="line"><span style="color:#56949F">    anyOf</span><span style="color:#797593">:</span></span>
<span class="line"><span style="color:#797593">      -</span><span style="color:#56949F"> $ref</span><span style="color:#797593">:</span><span style="color:#EA9D34"> "#/components/schemas/Weapon"</span></span>
<span class="line"><span style="color:#797593">      -</span><span style="color:#56949F"> $ref</span><span style="color:#797593">:</span><span style="color:#EA9D34"> "#/components/schemas/Armor"</span></span>
<span class="line"><span style="color:#797593">      -</span><span style="color:#56949F"> $ref</span><span style="color:#797593">:</span><span style="color:#EA9D34"> "#/components/schemas/GenericItem"</span></span></code></pre>
<figcaption>OpenAPI output for a union of objects</figcaption>
</figure>
<p>Overall, TypeSpec's various language features compile to OpenAPI that is generally longer and more complex, both in terms of syntax and semantics.</p>
<h3 id="composable-and-modular" tabindex="-1">Composable &amp; modular <a class="header-anchor" href="#composable-and-modular">#</a></h3>
<p>The ability to encapsulate API patterns into reusable components was one of the main reasons why we started working on TypeSpec in the first place. At scale, consistency across APIs and conformance with API guidelines becomes quite costly. Monumental effort is required from both API authors and API reviewers to ensure quality.</p>
<p>TypeSpec's API components make consistency easy. API designers can encapsulate blessed API patterns into components that API authors import and use. In this way, API designers are assured that the API is correct simply by virtue of using the component, and API authors don't need to implement complex high-level patterns in JSON.</p>
<p>A common example is pagination<sup class="footnote-ref"><a href="#fn6" id="fnref6">[6]</a></sup>. Using TypeSpec, we can define a template that defines the shape of our page, and use that for every paged endpoint.</p>
<figure>
<pre class="shiki rose-pine-dawn" style="background-color:#faf4ed;color:#575279" tabindex="0"><code><span class="line"><span style="color:#286983">model</span><span style="color:#56949F"> Page</span><span style="color:#797593">&#x3C;</span><span style="color:#56949F">T</span><span style="color:#797593">></span><span style="color:#797593"> {</span></span>
<span class="line"><span style="color:#D7827E;font-style:italic">  items</span><span style="color:#286983">:</span><span style="color:#56949F"> T</span><span style="color:#797593">[];</span></span>
<span class="line"><span style="color:#D7827E;font-style:italic">  size</span><span style="color:#286983">:</span><span style="color:#56949F"> int32</span><span style="color:#797593">;</span></span>
<span class="line"><span style="color:#D7827E;font-style:italic">  nextLink</span><span style="color:#286983">:</span><span style="color:#56949F"> url</span><span style="color:#797593">;</span></span>
<span class="line"><span style="color:#D7827E;font-style:italic">  prevLink</span><span style="color:#286983">:</span><span style="color:#56949F"> url</span><span style="color:#797593">;</span></span>
<span class="line"><span style="color:#797593">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#56949F">@route</span><span style="color:#797593">(</span><span style="color:#EA9D34">"/characters"</span><span style="color:#797593">)</span></span>
<span class="line"><span style="color:#286983">op</span><span style="color:#D7827E"> listCharacters</span><span style="color:#797593">()</span><span style="color:#286983">:</span><span style="color:#56949F"> Page</span><span style="color:#797593">&#x3C;</span><span style="color:#56949F">Character</span><span style="color:#797593">>;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#56949F">@route</span><span style="color:#797593">(</span><span style="color:#EA9D34">"/items"</span><span style="color:#797593">)</span></span>
<span class="line"><span style="color:#286983">op</span><span style="color:#D7827E"> listItems</span><span style="color:#797593">()</span><span style="color:#286983">:</span><span style="color:#56949F"> Page</span><span style="color:#797593">&#x3C;</span><span style="color:#56949F">Item</span><span style="color:#797593">>;</span></span></code></pre>
<figcaption>A TypeSpec for paginated endpoints</figcaption>
</figure>
<p>Another common use for templates is defining your standard error shapes. For example, if every endpoint might return a <code>403</code> error, we can express that with a template:</p>
<figure>
<pre class="shiki rose-pine-dawn" style="background-color:#faf4ed;color:#575279" tabindex="0"><code><span class="line"><span style="color:#286983">alias</span><span style="color:#56949F"> WithStandardErrors</span><span style="color:#797593">&#x3C;</span><span style="color:#56949F">T</span><span style="color:#797593">></span><span style="color:#286983"> =</span><span style="color:#56949F"> T</span><span style="color:#575279"> | </span><span style="color:#56949F">ForbiddenResponse</span><span style="color:#797593">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#56949F">@route</span><span style="color:#797593">(</span><span style="color:#EA9D34">"/characters"</span><span style="color:#797593">)</span></span>
<span class="line"><span style="color:#286983">op</span><span style="color:#D7827E"> listCharacters</span><span style="color:#797593">()</span><span style="color:#286983">:</span><span style="color:#56949F"> WithStandardErrors</span><span style="color:#797593">&#x3C;</span><span style="color:#56949F">Page</span><span style="color:#797593">&#x3C;</span><span style="color:#56949F">Character</span><span style="color:#797593">>>;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#56949F">@route</span><span style="color:#797593">(</span><span style="color:#EA9D34">"/items"</span><span style="color:#797593">)</span></span>
<span class="line"><span style="color:#286983">op</span><span style="color:#D7827E"> listItems</span><span style="color:#797593">()</span><span style="color:#286983">:</span><span style="color:#56949F"> WithStandardErrors</span><span style="color:#797593">&#x3C;</span><span style="color:#56949F">Page</span><span style="color:#797593">&#x3C;</span><span style="color:#56949F">Item</span><span style="color:#797593">>>;</span></span></code></pre>
<figcaption>A TypeSpec for standard response shapes</figcaption>
</figure>
<p>In Azure, we have dozens of these templates, which encapsulate the API patterns we use across Azure's API surface area. We package these templates into modules that are imported by service owners when they're writing their API spec. They don't need to know that a &quot;long-running operation&quot; uses a particular HTTP verb with a payload of a specific shape, they just provide the long-running operation template a couple parameters specific to their API and they're done. API authors are happy, reviewers are happy.</p>
<h2 id="wrapping-up" tabindex="-1">Wrapping up <a class="header-anchor" href="#wrapping-up">#</a></h2>
<p>This just scratches the surface of what it's possible to do with TypeSpec. There are many other features that combine to make TypeSpec extremely productive to use, producing OpenAPI documents that can be well over 10x the size. When writing APIs is this productive, I think API-first starts to look not only viable, but attractive.</p>
<p>In later posts, I'll be sharing some more details about fun things TypeSpec can do. Topics may include its support for other protocols (e.g. Protobuf, JSON Schema), TypeSpec's extensibility model and how you can add your own decorators or emit your own output using TypeScript, how TypeSpec enables higher quality code generation, and future directions around pagination and support for streaming APIs. If you're interested in a particular topic, feel free to say so on <a href="https://twitter.com/bterlson">twitter</a>.</p>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>OpenAPI doesn't make it easy to generate good code. JSON Schema is a great vocabulary for generating data validators but not great at driving high quality codegen. Microsoft's attempts to get good codegen from OpenAPI involved <a href="http://azure.github.io/autorest/extensions/">a number of proprietary extensions</a>. <a href="#fnref1" class="footnote-backref">â†©ï¸Ž</a></p>
</li>
<li id="fn2" class="footnote-item"><p>API first refers to the practice of building your API specification up front, before any code is written, ensuring the API meets business requirements before committing to code and, in theory, resulting in improved consistency, reusability, and faster development time. <a href="#fnref2" class="footnote-backref">â†©ï¸Ž</a></p>
</li>
<li id="fn3" class="footnote-item"><p>Some lesser-used features are not supported, like callbacks, but we're working on them. Some more-often-used features are also not supported, but we are working on them as we speak, like examples and xml. <a href="#fnref3" class="footnote-backref">â†©ï¸Ž</a></p>
</li>
<li id="fn4" class="footnote-item"><p>This shouldn't be a surprise - TypeScript is a superset of JavaScript, aka the J in JSON. <a href="#fnref4" class="footnote-backref">â†©ï¸Ž</a></p>
</li>
<li id="fn5" class="footnote-item"><p>OpenAPI afficianados will likely question this choice. Much discussion was had about whether oneOf or anyOf would be most appropriate here. Ultimately my opinion is it doesn't matter so much, in practice the ecosystem seems to treat both <code>anyOf</code> and <code>allOf</code> as the same thing. If you need the other choice, you can use the <code>@oneOf</code> decorator from the <code>@typespec/openapi</code> package. <a href="#fnref5" class="footnote-backref">â†©ï¸Ž</a></p>
</li>
<li id="fn6" class="footnote-item"><p>Pagination is an area that TypeSpec has some additional work to do. While OpenAPI doesn't have the ability to explicitly define paginated endpoints, I believe clients should know that an endpoint is paginated so it can expose a friendlier interface to iterate over all the items in the collection. <a href="#fnref6" class="footnote-backref">â†©ï¸Ž</a></p>
</li>
</ol>
</section>

<ul class="links-nextprev"><li>Next: <a href="/blog/what-is-a-json-number/">What even is a JSON Number?</a></li>
</ul>

		</main>

		<footer></footer>

		<!-- This page `/blog/typespec-for-openapi/` was built on 2024-04-01T20:34:49.078Z -->
	</body>
</html>
